// Bluetooth Quick Manager - Full Featured Extension
// Features: Toggle Bluetooth, Connect/Disconnect devices, Scan & Pair new devices
const { St, Clutter, GObject, Gio, GLib } = imports.gi;
const Main = imports.ui.main;
const PanelMenu = imports.ui.panelMenu;
const PopupMenu = imports.ui.popupMenu;

// Helper functions:
function isTrashBluetoothDevice(device) {
    const name = device?.name || "";

    // Regex MAC address: AA:BB:CC:DD:EE:FF
    const macRegex = /^[0-9A-Fa-f]{2}(:[0-9A-Fa-f]{2}){5}$/;

    return macRegex.test(name);
}

// Bluetooth Manager Button
const BluetoothManagerButton = GObject.registerClass(
class BluetoothManagerButton extends PanelMenu.Button {
    _init() {
        super._init(0.0, 'Bluetooth Manager');
        
        // Icon on topbar
        this._icon = new St.Icon({
            icon_name: 'bluetooth-active-symbolic',
            style_class: 'system-status-icon',
        });
        this.add_child(this._icon);
        
        // Adapter path cache
        this._adapterPath = null;
        this._isScanning = false;
        this._spinnerTimeout = null;
        this._discoveredDevices = new Map(); // Track discovered devices to prevent duplicates
        
        // D-Bus proxy for Bluetooth
        this._initDBus();
        
        // Get adapter path immediately on startup
        this._initAdapterPath();
        
        // Build menu
        this._buildMenu();
        
        // Refresh menu when opened and auto-start scan
        // Stop scan when menu closes
        this.menu.connect('open-state-changed', (menu, isOpen) => {
            log('[BT] Menu open-state-changed: isOpen=' + isOpen);
            
            if (isOpen) {
                log('[BT] Menu opened, refreshing...');
                this._refreshMenu();
                
                // Auto-start scan if not already scanning
                if (!this._isScanning && this._adapterPath) {
                    log('[BT] Auto-starting scan, adapter: ' + this._adapterPath);
                    this._startScan();
                } else {
                    log('[BT] Not starting scan: isScanning=' + this._isScanning + ', adapterPath=' + this._adapterPath);
                }
            } else {
                log('[BT] Menu closed');
                // Stop scan when menu closes
                if (this._isScanning) {
                    log('[BT] Stopping scan...');
                    this._stopScan();
                }
            }
        });
    }
    
    _initDBus() {
        this._bluezProxy = null;
        
        try {
            const BluezInterface = Gio.DBusProxy.makeProxyWrapper(
                '<node>\
                  <interface name="org.freedesktop.DBus.ObjectManager">\
                    <method name="GetManagedObjects">\
                      <arg type="a{oa{sa{sv}}}" direction="out"/>\
                    </method>\
                    <signal name="InterfacesAdded">\
                      <arg type="o" name="object"/>\
                      <arg type="a{sa{sv}}" name="interfaces"/>\
                    </signal>\
                    <signal name="InterfacesRemoved">\
                      <arg type="o" name="object"/>\
                      <arg type="as" name="interfaces"/>\
                    </signal>\
                  </interface>\
                </node>'
            );
            
            this._bluezProxy = new BluezInterface(
                Gio.DBus.system,
                'org.bluez',
                '/',
                (proxy, error) => {
                    if (error) {
                        log('BlueZ proxy error: ' + error.message);
                    } else {
                        // Listen for new devices - INCREMENTAL DISCOVERY
                        this._bluezProxy.connectSignal('InterfacesAdded', (proxy, sender, [object, interfaces]) => {
                            log('[BT] InterfacesAdded signal received for: ' + object);
                            
                            if ('org.bluez.Device1' in interfaces) {
                                log('[BT] Device1 interface found, isScanning: ' + this._isScanning);
                                
                                if (this._isScanning) {
                                    let deviceProps = interfaces['org.bluez.Device1'];
                                    let device = {
                                        path: object,
                                        name: deviceProps.Name?.unpack() || deviceProps.Address?.unpack() || 'Unknown Device',
                                        connected: deviceProps.Connected?.unpack() || false,
                                        paired: deviceProps.Paired?.unpack() || false,
                                        address: deviceProps.Address?.unpack() || '',
                                        rssi: deviceProps.RSSI?.unpack() || null,
                                        alias: deviceProps.Alias?.unpack() || null,
                                        timestamp: Date.now() // Add timestamp for sorting
                                    };
                                    
                                    log('[BT] Device details: name=' + device.name + ', alias=' + device.alias + ', paired=' + device.paired + ', rssi=' + device.rssi);
                                    
                                    // Filter out trash devices
                                    if (isTrashBluetoothDevice(device)) {
                                        log('[BT] Ignoring trash device: ' + device.name);
                                        return;
                                    }
                                    
                                    // Only add unpaired devices during scan
                                    if (!device.paired) {
                                        log('[BT] Adding unpaired device with real name: ' + device.name);
                                        this._addDiscoveredDevice(device);
                                    } else {
                                        log('[BT] Skipping paired device: ' + device.name);
                                    }
                                }
                            }
                        });
                        
                        // Listen for removed devices - Remove from list
                        this._bluezProxy.connectSignal('InterfacesRemoved', (proxy, sender, [object, interfaces]) => {
                            log('[BT] InterfacesRemoved signal received for: ' + object);
                            
                            if (interfaces.includes('org.bluez.Device1')) {
                                log('[BT] Device1 interface removed');
                                
                                // Remove from discovered devices if present
                                if (this._discoveredDevices.has(object)) {
                                    log('[BT] Removing device from list: ' + object);
                                    this._discoveredDevices.delete(object);
                                    
                                    // Remove from UI - find and remove the menu item
                                    let items = this._availableSection._getMenuItems();
                                    for (let item of items) {
                                        if (item._devicePath === object) {
                                            item.destroy();
                                            log('[BT] Device removed from UI');
                                            break;
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            );
        } catch (e) {
            log('Error initializing D-Bus: ' + e.message);
        }
    }
    
    _initAdapterPath() {
        // Get adapter path immediately on startup
        if (!this._bluezProxy) {
            log('[BT] BlueZ proxy not ready yet, will retry...');
            // Retry after proxy is ready
            GLib.timeout_add(GLib.PRIORITY_DEFAULT, 500, () => {
                this._initAdapterPath();
                return GLib.SOURCE_REMOVE;
            });
            return;
        }
        
        log('[BT] Getting adapter path on startup...');
        
        this._bluezProxy.GetManagedObjectsRemote((result, error) => {
            if (error) {
                log('[BT] Error getting adapter path: ' + error.message);
                return;
            }
            
            let [objects] = result;
            
            for (let path in objects) {
                let interfaces = objects[path];
                
                if ('org.bluez.Adapter1' in interfaces) {
                    this._adapterPath = path;
                    log('[BT] Adapter path initialized: ' + this._adapterPath);
                    
                    // Update icon based on adapter state
                    let adapterProps = interfaces['org.bluez.Adapter1'];
                    let powered = adapterProps.Powered?.unpack() || false;
                    this._icon.icon_name = powered ? 
                        'bluetooth-active-symbolic' : 
                        'bluetooth-disabled-symbolic';
                    
                    break;
                }
            }
            
            if (!this._adapterPath) {
                log('[BT] No Bluetooth adapter found');
            }
        });
    }
    
    _buildMenu() {
        // Set fixed width for menu to prevent resize when items added
        this.menu.actor.style = 'min-width: 380px;';
        
        // Toggle Bluetooth
        this._bluetoothToggle = new PopupMenu.PopupSwitchMenuItem(
            'Bluetooth',
            true
        );
        
        // Override activate to prevent menu close
        let originalActivate = this._bluetoothToggle.activate;
        this._bluetoothToggle.activate = (event) => {
            this._bluetoothToggle.toggle();
            return Clutter.EVENT_STOP;
        };
        
        this._bluetoothToggle.connect('toggled', (item) => {
            this._toggleBluetoothWithFallback(item.state);
        });
        this.menu.addMenuItem(this._bluetoothToggle);
        
        this.menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
        
        // Settings button (moved up, right after Bluetooth toggle)
        let settingsItem = new PopupMenu.PopupMenuItem('Bluetooth Settings');
        settingsItem.connect('activate', () => {
            this._openBluetoothSettings();
            this.menu.close();
        });
        this.menu.addMenuItem(settingsItem);
        
        this.menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
        
        // Paired devices section with label
        this._pairedLabel = new PopupMenu.PopupMenuItem('Paired Devices', {
            reactive: false,
            style_class: 'popup-subtitle-menu-item'
        });
        this.menu.addMenuItem(this._pairedLabel);
        
        this._devicesSection = new PopupMenu.PopupMenuSection();
        this.menu.addMenuItem(this._devicesSection);
        
        this.menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
        
        // Available devices header with spinner
        let availableHeaderBox = new St.BoxLayout({
            vertical: false,
            x_expand: true,
            style: 'spacing: 8px;'
        });
        
        let availableLabelText = new St.Label({
            text: 'Available Devices',
            y_align: Clutter.ActorAlign.CENTER,
            x_expand: true,
            style_class: 'popup-subtitle-menu-item'
        });
        availableHeaderBox.add_child(availableLabelText);
        
        // Spinner icon (shows when scanning)
        this._scanSpinner = new St.Icon({
            icon_name: 'process-working-symbolic',
            icon_size: 16,
            style: 'color: #888;'
        });
        this._scanSpinner.set_pivot_point(0.5, 0.5);
        availableHeaderBox.add_child(this._scanSpinner);
        
        this._availableLabel = new PopupMenu.PopupBaseMenuItem({
            reactive: false,
            can_focus: false
        });
        this._availableLabel.actor.add_child(availableHeaderBox);
        this._availableLabel.visible = false;
        this.menu.addMenuItem(this._availableLabel);
        
        // Create scrollable section for available devices
        this._availableScrollView = new St.ScrollView({
            style_class: 'available-devices-scroll',
            hscrollbar_policy: St.PolicyType.NEVER,
            vscrollbar_policy: St.PolicyType.AUTOMATIC,
            overlay_scrollbars: true,
            visible: false
        });
        
        this._availableSection = new PopupMenu.PopupMenuSection();
        this._availableScrollView.add_actor(this._availableSection.actor);
        
        // Add scroll view to menu
        let scrollItem = new PopupMenu.PopupBaseMenuItem({ 
            reactive: false,
            can_focus: false
        });
        scrollItem.actor.add_child(this._availableScrollView);
        this.menu.addMenuItem(scrollItem);
        
        // Set max height for scroll view
        this._availableScrollView.set_style('max-height: 300px;');
    }
    
    _refreshMenu() {
        this._devicesSection.removeAll();
        
        // Don't clear available section - it's managed by scan
        
        if (!this._bluezProxy) {
            let item = new PopupMenu.PopupMenuItem('Bluetooth not available');
            item.setSensitive(false);
            this._devicesSection.addMenuItem(item);
            return;
        }
        
        this._bluezProxy.GetManagedObjectsRemote((result, error) => {
            if (error) {
                log('Error getting devices: ' + error.message);
                let item = new PopupMenu.PopupMenuItem('Error loading devices');
                item.setSensitive(false);
                this._devicesSection.addMenuItem(item);
                return;
            }
            
            let [objects] = result;
            let pairedDevices = [];
            
            for (let path in objects) {
                let interfaces = objects[path];
                
                if ('org.bluez.Adapter1' in interfaces) {
                    this._adapterPath = path;
                    let adapterProps = interfaces['org.bluez.Adapter1'];
                    let powered = adapterProps.Powered?.unpack() || false;
                    
                    this._bluetoothToggle.setToggleState(powered);
                    this._icon.icon_name = powered ? 
                        'bluetooth-active-symbolic' : 
                        'bluetooth-disabled-symbolic';
                }
                
                if ('org.bluez.Device1' in interfaces) {
                    let deviceProps = interfaces['org.bluez.Device1'];
                    let device = {
                        path: path,
                        name: deviceProps.Name?.unpack() || deviceProps.Address?.unpack() || 'Unknown Device',
                        connected: deviceProps.Connected?.unpack() || false,
                        paired: deviceProps.Paired?.unpack() || false,
                        trusted: deviceProps.Trusted?.unpack() || false,
                        address: deviceProps.Address?.unpack() || '',
                        rssi: deviceProps.RSSI?.unpack() || null,
                    };
                    
                    if (device.paired) {
                        pairedDevices.push(device);
                    }
                }
            }
            
            // Display paired devices
            if (pairedDevices.length === 0) {
                let item = new PopupMenu.PopupMenuItem('No paired devices');
                item.setSensitive(false);
                this._devicesSection.addMenuItem(item);
            } else {
                pairedDevices.sort((a, b) => {
                    if (a.connected && !b.connected) return -1;
                    if (!a.connected && b.connected) return 1;
                    return a.name.localeCompare(b.name);
                });
                
                pairedDevices.forEach(device => {
                    this._addPairedDeviceItem(device);
                });
            }
        });
    }
    
    _addPairedDeviceItem(device) {
        let item = new PopupMenu.PopupSwitchMenuItem(
            device.name,
            device.connected
        );
        
        // Device icon
        let icon = new St.Icon({
            icon_name: this._getDeviceIcon(device),
            style_class: 'popup-menu-icon',
        });
        item.insert_child_at_index(icon, 1);
        
        // Connection status indicator (before device name)
        if (device.connected) {
            let connectedIcon = new St.Icon({
                icon_name: 'emblem-ok-symbolic',
                style_class: 'popup-menu-icon',
                icon_size: 14,
                style: 'color: #4ade80; margin-left: 4px;' // Green color
            });
            item.insert_child_at_index(connectedIcon, 2);
        }
        
        // Create spinner icon (hidden by default)
        let spinner = new St.Icon({
            icon_name: 'process-working-symbolic',
            style_class: 'popup-menu-icon',
            icon_size: 16,
            visible: false
        });

        spinner.set_pivot_point(0.5, 0.5);
        
        // Get the switch widget reference
        let switchWidget = item._switch;
        
        // Add spinner to the end of item
        item.actor.add_child(spinner);
        
        // Override activate to prevent menu close
        let originalActivate = item.activate;
        item.activate = (event) => {
            item.toggle();
            return Clutter.EVENT_STOP;
        };
        
        // Connect toggle handler with spinner
        let spinnerTimeout = null;
        let isConnecting = false; // Track connection state
        
        item.connect('toggled', (item) => {
            // Block if already connecting
            if (isConnecting) {
                log('[BT] Already connecting, ignoring toggle');
                // Revert the toggle
                item.setToggleState(!item.state);
                return;
            }
            
            let targetState = item.state;
            
            log('[BT] Toggle device: ' + device.name + ' to ' + targetState);
            
            // Set connecting flag
            isConnecting = true;
            
            // Disable the item to prevent clicks
            item.reactive = false;
            item.can_focus = false;
            
            // Hide switch, show spinner
            switchWidget.hide();
            spinner.show();
            
            // Start spinner animation
            let angle = 0;
            spinnerTimeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 100, () => {
                angle = (angle + 30) % 360;
                spinner.set_rotation_angle(Clutter.RotateAxis.Z_AXIS, angle);
                return GLib.SOURCE_CONTINUE;
            });
            
            // Perform connection/disconnection with callback
            this._toggleDeviceWithCallback(device.path, targetState, (success) => {
                log('[BT] Toggle result: ' + success);
                
                // Clear connecting flag
                isConnecting = false;
                
                // Re-enable the item
                item.reactive = true;
                item.can_focus = true;
                
                // Stop spinner
                if (spinnerTimeout) {
                    GLib.source_remove(spinnerTimeout);
                    spinnerTimeout = null;
                }
                spinner.set_rotation_angle(Clutter.RotateAxis.Z_AXIS, 0);
                
                // Show switch, hide spinner
                spinner.hide();
                switchWidget.show();
                
                // Update switch state based on result
                if (!success) {
                    // Revert switch state if failed
                    item.setToggleState(!targetState);
                }
            });
        });
        
        this._devicesSection.addMenuItem(item);
    }
    
    _addAvailableDeviceItemAtTop(device) {
        let item = new PopupMenu.PopupBaseMenuItem({ 
            reactive: true,
            style_class: 'popup-menu-item'
        });
        
        // Set style after creation
        item.actor.set_style('padding-left: 0px; padding-right: 12px;');
        item.setOrnament(PopupMenu.Ornament.NONE);
        
        let box = new St.BoxLayout({ 
            vertical: false,
            x_expand: true,
            style: 'spacing: 12px;'
        });
        
        // Device icon
        let icon = new St.Icon({
            icon_name: this._getDeviceIcon(device),
            style_class: 'popup-menu-icon',
            icon_size: 16
        });

        box.add_child(icon);
        
        // Device name (use alias if available, fallback to name)
        let nameCol = new St.BoxLayout({ vertical: true, y_expand: true, x_expand: true });
        let displayName = device.alias || device.name;
        let nameLabel = new St.Label({ 
            text: displayName,
            y_align: Clutter.ActorAlign.CENTER,
            x_expand: true,
            style: 'font-size: 0.9em;'
        });
        box.add_child(nameLabel);
        box.add_child(nameCol);

        
        // Signal strength indicator
        if (device.rssi) {
            let signalIcon = new St.Icon({
                icon_name: this._getSignalIcon(device.rssi),
                style_class: 'popup-menu-icon',
                icon_size: 14
            });
            box.add_child(signalIcon);
        }
        
        // Pair button with spinner
        let pairButton = new St.Button({
            label: 'Pair',
            style_class: 'button',
            style: 'padding: 4px 12px; font-size: 0.85em;'
        });
        
        // Spinner for pairing (hidden by default)
        let pairSpinner = new St.Icon({
            icon_name: 'process-working-symbolic',
            icon_size: 14,
            visible: false
        });
        pairSpinner.set_pivot_point(0.5, 0.5);
        
        let isPairing = false; // Track pairing state
        
        pairButton.connect('clicked', () => {
            // Block if already pairing
            if (isPairing) {
                log('[BT] Already pairing, ignoring click');
                return;
            }
            
            log('[BT] Starting pair for: ' + device.name);
            
            // Set pairing flag
            isPairing = true;
            
            // Hide button label, show spinner
            pairButton.label = '';
            pairButton.set_child(pairSpinner);
            pairSpinner.show();
            
            // Disable button
            pairButton.reactive = false;
            
            // Start spinner animation
            let angle = 0;
            let spinnerTimeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 100, () => {
                angle = (angle + 30) % 360;
                pairSpinner.set_rotation_angle(Clutter.RotateAxis.Z_AXIS, angle);
                return GLib.SOURCE_CONTINUE;
            });
            
            // Pair device with callback
            this._pairDeviceWithCallback(device.path, (success) => {
                log('[BT] Pair result: ' + success);
                
                // Clear pairing flag
                isPairing = false;
                
                // Stop spinner
                if (spinnerTimeout) {
                    GLib.source_remove(spinnerTimeout);
                }
                pairSpinner.set_rotation_angle(Clutter.RotateAxis.Z_AXIS, 0);
                
                // Restore button
                pairSpinner.hide();
                pairButton.set_child(null);
                pairButton.label = success ? 'Paired!' : 'Pair';
                pairButton.reactive = true;
                
                // If successful, refresh menu after delay to show in Paired section
                if (success) {
                    GLib.timeout_add(GLib.PRIORITY_DEFAULT, 1000, () => {
                        this._refreshMenu();
                        return GLib.SOURCE_REMOVE;
                    });
                }
            });
        });
        box.add_child(pairButton);
        
        item.actor.add_child(box);
        
        // Store device path for removal tracking
        item._devicePath = device.path;
        
        // Add to TOP (index 0) - newest devices first
        this._availableSection.addMenuItem(item, 0);
        
        log('[BT] Device item added to TOP of menu successfully');
    }
    
    _getDeviceIcon(device) {
        let name = device.name.toLowerCase();
        if (name.includes('headphone') || name.includes('airpods') || 
            name.includes('buds') || name.includes('earphone')) {
            return 'audio-headphones-symbolic';
        } else if (name.includes('keyboard')) {
            return 'input-keyboard-symbolic';
        } else if (name.includes('mouse')) {
            return 'input-mouse-symbolic';
        } else if (name.includes('speaker')) {
            return 'audio-speakers-symbolic';
        } else if (name.includes('phone')) {
            return 'phone-symbolic';
        } else if (name.includes('watch')) {
            return 'watch-symbolic';
        }
        return 'bluetooth-symbolic';
    }
    
    _getSignalIcon(rssi) {
        // RSSI typically ranges from -100 (worst) to 0 (best)
        if (rssi >= -50) return 'network-wireless-signal-excellent-symbolic';
        if (rssi >= -60) return 'network-wireless-signal-good-symbolic';
        if (rssi >= -70) return 'network-wireless-signal-ok-symbolic';
        return 'network-wireless-signal-weak-symbolic';
    }
    
    _startScan() {
        // Don't start if already scanning
        if (this._isScanning) {
            log('[BT] Scan already running, skipping');
            return;
        }
        
        log('[BT] Starting scan on adapter: ' + this._adapterPath);
        
        try {
            Gio.DBus.system.call(
                'org.bluez',
                this._adapterPath,
                'org.bluez.Adapter1',
                'StartDiscovery',
                null,
                null,
                Gio.DBusCallFlags.NONE,
                -1,
                null,
                (connection, result) => {
                    try {
                        connection.call_finish(result);
                        this._isScanning = true;
                        
                        log('[BT] Scan started successfully, isScanning: ' + this._isScanning);
                        
                        // Show available devices section
                        this._availableLabel.visible = true;
                        this._availableScrollView.visible = true;
                        
                        // Start spinner animation
                        this._startSpinnerAnimation();
                        
                        log('[BT] Available devices section now visible with spinner');
                        
                        // NO TIMEOUT - Continuous scan like Ubuntu
                        
                    } catch (e) {
                        log('[BT] ERROR starting scan: ' + e.message);
                        Main.notify('Bluetooth Manager', 'Failed to start scan: ' + e.message);
                    }
                }
            );
        } catch (e) {
            log('[BT] ERROR in startScan: ' + e.message);
            Main.notify('Bluetooth Manager', 'Error: ' + e.message);
        }
    }
    
    _stopScan() {
        if (!this._isScanning) {
            return;
        }
        
        // Stop spinner animation
        this._stopSpinnerAnimation();
        
        try {
            Gio.DBus.system.call(
                'org.bluez',
                this._adapterPath,
                'org.bluez.Adapter1',
                'StopDiscovery',
                null,
                null,
                Gio.DBusCallFlags.NONE,
                -1,
                null,
                (connection, result) => {
                    try {
                        connection.call_finish(result);
                        this._isScanning = false;
                        
                        log('[BT] Scan stopped');
                        
                        // Hide available devices section when menu closes
                        this._availableLabel.visible = false;
                        this._availableScrollView.visible = false;
                        
                        // Clear devices
                        this._availableSection.removeAll();
                        this._discoveredDevices.clear();
                        
                    } catch (e) {
                        log('Error stopping scan: ' + e.message);
                    }
                }
            );
        } catch (e) {
            log('Error stopping scan: ' + e.message);
        }
    }
    
    _startSpinnerAnimation() {
        if (this._spinnerTimeout) {
            return;
        }
        
        let angle = 0;
        this._spinnerTimeout = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 100, () => {
            angle = (angle + 30) % 360;
            this._scanSpinner.set_rotation_angle(Clutter.RotateAxis.Z_AXIS, angle);
            return GLib.SOURCE_CONTINUE;
        });
    }
    
    _stopSpinnerAnimation() {
        if (this._spinnerTimeout) {
            GLib.source_remove(this._spinnerTimeout);
            this._spinnerTimeout = null;
            this._scanSpinner.set_rotation_angle(Clutter.RotateAxis.Z_AXIS, 0);
        }
    }
    
    
    _addDiscoveredDevice(device) {
        log('[BT] _addDiscoveredDevice called for: ' + device.name + ' (path: ' + device.path + ')');
        
        // Only add if not already discovered and scanning
        if (!this._isScanning) {
            log('[BT] Not scanning, skipping device');
            return;
        }
        
        if (this._discoveredDevices.has(device.path)) {
            log('[BT] Device already discovered, skipping');
            return;
        }
                
        log('[BT] Adding device to UI: ' + device.name);
        this._discoveredDevices.set(device.path, device);
        
        // Add to TOP of list (newest first) by using index 0
        this._addAvailableDeviceItemAtTop(device);
        
        log('[BT] Device added successfully, total devices: ' + this._discoveredDevices.size);
    }
    
    _pairDevice(devicePath) {
        Main.notify('Bluetooth Manager', 'Pairing device...');
        
        try {
            Gio.DBus.system.call(
                'org.bluez',
                devicePath,
                'org.bluez.Device1',
                'Pair',
                null,
                null,
                Gio.DBusCallFlags.NONE,
                60000, // 60 second timeout for pairing
                null,
                (connection, result) => {
                    try {
                        connection.call_finish(result);
                        Main.notify('Bluetooth Manager', 'Device paired successfully!');
                        
                        // Auto-connect after pairing
                        GLib.timeout_add(GLib.PRIORITY_DEFAULT, 1000, () => {
                            this._connectDevice(devicePath);
                            return GLib.SOURCE_REMOVE;
                        });
                        
                        this._refreshMenu();
                    } catch (e) {
                        log('Error pairing device: ' + e.message);
                        Main.notify('Bluetooth Manager', 'Failed to pair device: ' + e.message);
                    }
                }
            );
        } catch (e) {
            log('Error pairing device: ' + e.message);
        }
    }
    
    _pairDeviceWithCallback(devicePath, callback) {
        try {
            Gio.DBus.system.call(
                'org.bluez',
                devicePath,
                'org.bluez.Device1',
                'Pair',
                null,
                null,
                Gio.DBusCallFlags.NONE,
                60000, // 60 second timeout for pairing
                null,
                (connection, result) => {
                    try {
                        connection.call_finish(result);
                        log('[BT] Device paired successfully');
                        
                        // Auto-connect after pairing
                        GLib.timeout_add(GLib.PRIORITY_DEFAULT, 500, () => {
                            this._connectDevice(devicePath);
                            return GLib.SOURCE_REMOVE;
                        });
                        
                        // Call callback with success
                        if (callback) callback(true);
                        
                    } catch (e) {
                        log('[BT] Error pairing device: ' + e.message);
                        Main.notify('Bluetooth Manager', 'Failed to pair: ' + e.message);
                        
                        // Call callback with failure
                        if (callback) callback(false);
                    }
                }
            );
        } catch (e) {
            log('[BT] Error calling pair: ' + e.message);
            
            // Call callback with failure
            if (callback) callback(false);
        }
    }
    
    _connectDevice(devicePath) {
        try {
            Gio.DBus.system.call(
                'org.bluez',
                devicePath,
                'org.bluez.Device1',
                'Connect',
                null,
                null,
                Gio.DBusCallFlags.NONE,
                30000,
                null,
                (connection, result) => {
                    try {
                        connection.call_finish(result);
                        this._refreshMenu();
                    } catch (e) {
                        log('Error connecting device: ' + e.message);
                    }
                }
            );
        } catch (e) {
            log('Error connecting device: ' + e.message);
        }
    }
    
    _toggleBluetoothWithFallback(state) {
        if (this._adapterPath) {
            this._setAdapterPowerDBus(this._adapterPath, state, (success) => {
                if (!success) {
                    log('D-Bus method failed, trying rfkill...');
                    this._setAdapterPowerRfkill(state);
                }
            });
        } else {
            this._setAdapterPowerRfkill(state);
        }
    }
    
    _setAdapterPowerDBus(adapterPath, powered, callback) {
        try {
            Gio.DBus.system.call(
                'org.bluez',
                adapterPath,
                'org.freedesktop.DBus.Properties',
                'Set',
                GLib.Variant.new('(ssv)', [
                    'org.bluez.Adapter1',
                    'Powered',
                    GLib.Variant.new('b', powered)
                ]),
                null,
                Gio.DBusCallFlags.NONE,
                5000,
                null,
                (connection, result) => {
                    try {
                        connection.call_finish(result);
                        GLib.timeout_add(GLib.PRIORITY_DEFAULT, 500, () => {
                            this._refreshMenu();
                            return GLib.SOURCE_REMOVE;
                        });
                        if (callback) callback(true);
                    } catch (e) {
                        log('D-Bus set power error: ' + e.message);
                        this._bluetoothToggle.setToggleState(!powered);
                        if (callback) callback(false);
                    }
                }
            );
        } catch (e) {
            log('D-Bus call error: ' + e.message);
            this._bluetoothToggle.setToggleState(!powered);
            if (callback) callback(false);
        }
    }
    
    _setAdapterPowerRfkill(powered) {
        try {
            let command = powered ? 'rfkill unblock bluetooth' : 'rfkill block bluetooth';
            let [success, pid] = GLib.spawn_async(
                null,
                ['sh', '-c', command],
                null,
                GLib.SpawnFlags.SEARCH_PATH | GLib.SpawnFlags.DO_NOT_REAP_CHILD,
                null
            );
            
            if (success) {
                GLib.child_watch_add(GLib.PRIORITY_DEFAULT, pid, (pid, status) => {
                    GLib.spawn_close_pid(pid);
                    if (status === 0) {
                        GLib.timeout_add(GLib.PRIORITY_DEFAULT, 500, () => {
                            this._refreshMenu();
                            return GLib.SOURCE_REMOVE;
                        });
                    } else {
                        this._bluetoothToggle.setToggleState(!powered);
                    }
                });
            } else {
                this._bluetoothToggle.setToggleState(!powered);
            }
        } catch (e) {
            log('rfkill error: ' + e.message);
            this._bluetoothToggle.setToggleState(!powered);
        }
    }
    
    _toggleDevice(devicePath, connect) {
        try {
            Gio.DBus.system.call(
                'org.bluez',
                devicePath,
                'org.bluez.Device1',
                connect ? 'Connect' : 'Disconnect',
                null,
                null,
                Gio.DBusCallFlags.NONE,
                30000,
                null,
                (connection, result) => {
                    try {
                        connection.call_finish(result);
                        GLib.timeout_add(GLib.PRIORITY_DEFAULT, 1000, () => {
                            this._refreshMenu();
                            return GLib.SOURCE_REMOVE;
                        });
                    } catch (e) {
                        log('Device toggle error: ' + e.message);
                        this._refreshMenu();
                    }
                }
            );
        } catch (e) {
            log('Device toggle call error: ' + e.message);
            this._refreshMenu();
        }
    }
    
    _toggleDeviceWithCallback(devicePath, connect, callback) {
        try {
            Gio.DBus.system.call(
                'org.bluez',
                devicePath,
                'org.bluez.Device1',
                connect ? 'Connect' : 'Disconnect',
                null,
                null,
                Gio.DBusCallFlags.NONE,
                30000, // 30 second timeout
                null,
                (connection, result) => {
                    try {
                        connection.call_finish(result);
                        log('[BT] Device ' + (connect ? 'connected' : 'disconnected') + ' successfully');
                        
                        // Refresh menu after short delay
                        GLib.timeout_add(GLib.PRIORITY_DEFAULT, 500, () => {
                            this._refreshMenu();
                            return GLib.SOURCE_REMOVE;
                        });
                        
                        // Call callback with success
                        if (callback) callback(true);
                        
                    } catch (e) {
                        log('[BT] Device toggle error: ' + e.message);
                        Main.notify('Bluetooth Manager', 'Connection failed: ' + e.message);
                        
                        // Call callback with failure
                        if (callback) callback(false);
                    }
                }
            );
        } catch (e) {
            log('[BT] Device toggle call error: ' + e.message);
            
            // Call callback with failure
            if (callback) callback(false);
        }
    }
    
    _openBluetoothSettings() {
        const methods = [
            ['gnome-control-center', 'bluetooth'],
            ['XDG_CURRENT_DESKTOP=GNOME', 'gnome-control-center', 'bluetooth'],
            ['blueman-manager'],
            ['gnome-control-center'],
        ];
        
        let tried = 0;
        const tryNextMethod = () => {
            if (tried >= methods.length) {
                Main.notify(
                    'Bluetooth Manager',
                    'Cannot open Bluetooth settings.\nPlease open Settings manually.'
                );
                return;
            }
            
            let method = methods[tried];
            tried++;
            
            try {
                let [success, pid] = GLib.spawn_async(
                    null,
                    method,
                    null,
                    GLib.SpawnFlags.SEARCH_PATH | GLib.SpawnFlags.DO_NOT_REAP_CHILD,
                    null
                );
                
                if (success) {
                    GLib.child_watch_add(GLib.PRIORITY_DEFAULT, pid, (pid, status) => {
                        GLib.spawn_close_pid(pid);
                        if (status !== 0) {
                            tryNextMethod();
                        }
                    });
                } else {
                    tryNextMethod();
                }
            } catch (e) {
                tryNextMethod();
            }
        };
        
        tryNextMethod();
    }
    
    destroy() {
        // Stop spinner animation
        this._stopSpinnerAnimation();
        
        if (this._isScanning && this._adapterPath) {
            this._stopScan();
        }
        
        super.destroy();
    }
});

class Extension {
    constructor() {
        this._indicator = null;
    }
    
    enable() {
        log('Enabling Bluetooth Quick Manager');
        this._indicator = new BluetoothManagerButton();
        Main.panel.addToStatusArea('bluetooth-manager', this._indicator);
    }
    
    disable() {
        log('Disabling Bluetooth Quick Manager');
        if (this._indicator) {
            this._indicator.destroy();
            this._indicator = null;
        }
    }
}

function init() {
    return new Extension();
}
